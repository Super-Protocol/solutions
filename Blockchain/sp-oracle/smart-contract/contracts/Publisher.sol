// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./interfaces/IX509Verifier.sol";
import "./types/OracleData.sol";
import "./Publisher.sol";

/// @notice the "core" oracle smart-contract that the enclave script interacts with
contract Publisher {

    error PublicKeyIsNotInitialized();
    error SignatureIsNotUnique();
    error InvalidSignatureSize();
    error InvalidSessionKey();
    error AccessForbidden();
    error CallbackFailed();
    error InvalidQuote();

    // potentially updatable data
    mapping(address => bool) internal publishers; // -> is publisher
    mapping(address => address) private sessionPublicKeys; // publisher -> session key
    mapping(bytes32 => OracleData[]) public data; // key -> data array
    mapping(bytes32 => bool) private signatures; // signature -> already used

    bytes32 internal mrEnclave; // unique script identifier
    bytes32 internal mrSigner; // unique script identifier

    // must be immutable!
    IX509Verifier private X509Verifier; // external library with immutable root x509 certificate

    constructor(
        address[] memory _publishers,
        address _X509Verifier,
        bytes32 _mrEnclave,
        bytes32 _mrSigner
    ) {
        X509Verifier = IX509Verifier(_X509Verifier);
        mrSigner = _mrSigner;
        mrEnclave = _mrEnclave;

        uint32 idx;
        for (idx = 0; idx < _publishers.length; idx++) {
            publishers[_publishers[idx]] = true;
        }
    }

    // Signature protection
    function _getPrefixedHash(bytes32 _msgHash) internal pure returns (bytes32) {
        bytes32 prefixedHash = keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", _msgHash));
        return prefixedHash;
    }

    /// @notice This function checks if keyHash generated by the target app (script) and run in enclave.
    /// Session keyHash is an address of the wallet wich was been generated in anqlave.
    /// The wallet is generated every time, when script starts.
    /// @param msgHash - keccak256 hashed oracle data (fetched by script from target API)
    /// @param signature - ecdsa signature by session key. 
    /// The session private key exists only in the enclave and is generated each time the script is run.
    function _isSignedBySessionKey(address publisher, bytes32 msgHash, bytes memory signature) private view {
        if (signatures[msgHash]) {
            revert SignatureIsNotUnique();
        }

        address publicKeyHash = sessionPublicKeys[publisher];
        if (publicKeyHash == address(0)) {
            revert PublicKeyIsNotInitialized();
        }

        bytes32 r;
        bytes32 s;
        uint8 v;
        assembly {
            r := mload(add(signature, 0x20))
            s := mload(add(signature, 0x40))
            v := byte(0, mload(add(signature, 0x60)))
        }

        if (v < 27 || v > 28) {
            revert("Wrong version");
        }

        bytes32 prefixedHash = _getPrefixedHash(msgHash);
        if (publicKeyHash != ecrecover(prefixedHash, v, r, s)) {
            revert InvalidSessionKey();
        }
    }

    /// @notice
    function updateMrEnclave(bytes32 _mrEnclave) external onlyPublisher {
        mrEnclave = _mrEnclave;
    }

    /// @notice
    function updateMrSigner(bytes32 _mrSigner) external onlyPublisher {
        mrSigner = _mrSigner;
    }

    /// @notice
    function addPublisher(address publisher) external onlyPublisher {
        publishers[publisher] = true;
    }

    /// @notice
    function removePublisher(address publisher) external onlyPublisher {
        publishers[publisher] = false;
    }

    /// @notice Adding data from target API by trusted oracle-script.
    /// @param key - Identificator of data. e.g. keccak256('NewYork_temperatureT') 
    /// @param value - Target oracle data struct packed to bytes. Must contains 'nonce' for unique data hash.
    /// @param signature - Data(value) signated by session key.
    /// @param callback - Optional field. Can be used for callback to other contract.
    function add(
        bytes32 key,
        bytes calldata value,
        bytes calldata signature,
        bytes calldata callback
    ) public onlyPublisher {
        if (signature.length != 65) revert InvalidSignatureSize();
        
        bytes32 msgHash = keccak256(value);
        _isSignedBySessionKey(msg.sender, msgHash, signature);

        OracleData memory newData = OracleData({
            value: value,
            timestamp: uint32(block.timestamp)
        });

        data[key].push(newData);
        signatures[msgHash] = true;

        // optional
        if (callback.length > 0) {
            (, address dest, bytes4 funcSelector, uint256 gasLimit) = abi.decode(
                callback,
                (uint8, address, bytes4, uint256)
            );
            (bool success, ) = dest.call{gas: gasLimit}(abi.encodeWithSelector(funcSelector));
            if (!success) {
                revert CallbackFailed();
            }
        }
    }

    /// @notice
    /// @param deviceCert -
    /// @param intermCert -
    /// @param parsedQuoteData - ...
    /// @param sessionAddress - ... 
    function initSessionKey(
        ChunkedX509Cert calldata deviceCert,
        ChunkedX509Cert calldata intermCert,
        ChunkedSGXQuote calldata parsedQuoteData,
        address sessionAddress
    ) external onlyPublisher {
        bytes32 dataHash = keccak256(abi.encodePacked(sessionAddress));

        if (!X509Verifier.checkTEEQuote(
                deviceCert,
                intermCert,
                parsedQuoteData,
                mrEnclave,
                mrSigner,
                dataHash
            )
        ) {
            revert InvalidQuote();
        }

        sessionPublicKeys[msg.sender] = sessionAddress;
    }

    modifier onlyPublisher() {
        if (!publishers[msg.sender]) {
            revert AccessForbidden();
        }

        _;
    }
}